import {cArray, cStruct, CType, StructMembers, uint16, uint8} from "c-type-util";
import {calcChecksum} from "./calcChecksum";
import {PacketParseHelper} from "./PacketParseHelper";
import * as timers from "timers";
import {SchemaManager} from "./SchemaManager";
import {buf2mac} from "./util/buf2hex";

const regular_header_block_ctype = cStruct({
    id: cArray(uint8, 6), //6-byte ID = MAC
    ver: uint8,
})

type CallBack<T> = (data: T) => void;

export class DaqDecoder {
    private ph: PacketParseHelper = new PacketParseHelper();
    private readonly daqSchema: SchemaManager;

    //Used to interrupt the async parse loop
    private is_running: boolean = true;

    //Callbacks for different parse events
    private readonly onHeader: CallBack<any>;
    private readonly onData: CallBack<any>;
    private readonly onError: CallBack<Error>;

    //A CType generated by a data header, used to parse data
    private dataCType: CType<object> | undefined;

    constructor(daqSchema: SchemaManager, onData: CallBack<any>, onHeader: CallBack<any>, onError: CallBack<any>) {
        this.daqSchema = daqSchema;
        this.onData = onData;
        this.onHeader = onHeader;
        this.onError = onError;


        this.parse_runner().then(r => console.log("RUNNER STOPPED!!!!!!"));
    }

    feed(b: number) {
        this.ph.feed(b);
    }

    //Runs parsing logic and handles parsing errors while the decoder is running.
    async parse_runner() {
        while (this.is_running) {
            try {
                await this.parse_logic();
            } catch (e: any) {
                //console.error(e);
                setTimeout(() => this.onError(e), 0);
            }
        }
    }

    //Entrypoint for packet parsing. Switches logic based on packet type.
    async parse_logic() {
        const cmd = await this.ph.cType(uint8);
        switch (cmd) {
            case 0xAA: //Normal header
                await this.parse_regular_header();
                break;
            case 0x69: //Normal data
                await this.parse_data();
                break;
            default:
                throw new Error(`Unknown Command byte ${cmd}`);
        }
    }

    async parse_regular_header() {
        this.ph.resetChecksum();

        const len = await this.ph.cType(uint16);
        const raw_module_defs = await this.ph.cType(cArray(regular_header_block_ctype, len), true);
        const checksum = await this.ph.uint8_checksum();

        //Map each buffer ID into a MAC string
        const present_modules = raw_module_defs.map(mDef => ({...mDef, id: buf2mac(mDef.id)}));

        //Convert found IDs into definitions, from the DAQ schema.
        const module_definitions = present_modules.map(module => {
            const m = this.daqSchema.findById(module.id)

            if (!m)
                throw new Error(`Data contains module ID ${module.id} which doesn't exist in the DAQ schema.`);

            return m;
        });

        setTimeout(() => this.onHeader(module_definitions), 0);

        //Create the new CType to parse future data.
        const structMembers: { [key: string]: CType<any> } = {};

        module_definitions.forEach(d => {
            structMembers[d.name] = cStruct(d.type.rawDataStruct);
        });

        this.dataCType = cStruct(structMembers);
        //console.log(len, data, checksum, module_definitions);
    }

    async parse_data() {
        if (!this.dataCType)
            throw new Error(`Data header received without a loaded CType!`);

        this.ph.resetChecksum();

        const rawData = await this.ph.cType(this.dataCType, true);
        const checksum = await this.ph.uint8_checksum();

        const convertedData: any = {};
        for (const [k, v] of Object.entries(rawData)) {
            const mdef = this.daqSchema.findByName(k);
            convertedData[k] = mdef?.type.convert((rawData as any)[k], mdef?.config);
        }

        setTimeout(() => this.onData(convertedData), 0);
    }
}
